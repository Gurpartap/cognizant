#!/usr/bin/env ruby

require "cognizant/version"
require "gli"
require "formatador"
require "socket"
require "json"

include GLI::App

# Set the process name.
$0 = File.basename(__FILE__)

# Set to flush standard output/error immediately.
$stdout.sync = true
$stderr.sync = true

program_desc "administration utility for cognizantd"
@version = Cognizant::VERSION

sort_help :manually

desc "The socket lock file of the daemon server"
arg_name "FILE"
flag :socket, :type => String, :default_value => "/var/run/cognizant/cognizantd.sock"

desc "The server address of the daemon server"
arg_name "ADDRESS"
flag "bind-address", :type => String

desc "The server port of the daemon server"
arg_name "PORT"
flag :port, :type => Integer

desc "Username to use for authentication with server"
arg_name "USERNAME"
flag :username, :type => String

desc "Password to use for authentication with server"
arg_name "PASSWORD"
flag :password, :type => String

desc "Print the version number and exit"
switch :version, :negatable => false

desc "Turn on tracing, enabling full backtrace"
switch :trace, :negatable => false

desc "Display status of managed process(es) or group(s)"
arg_name "process_name", :optional
command :status do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :status, args) do |output|
      begin  
        JSON.parse(output)

        status_data = JSON.parse(output)
        status_data.each_with_index do |process, index|
          status_data[index]["State"]  = "[green]#{process["State"]}[/] since #{distance_of_time_in_words(Time.now.to_i - process["Since"])}"
          status_data[index]["Memory"] = number_to_human_size(process["Memory"] * 1024) # Convert kilobytes to bytes.
        end

        formatador = Formatador.new
        formatador.display_line
        formatador.display_table(status_data, ["Process", "Group", "State", "PID", "% CPU", "Memory"])
        formatador.display_line(Time.now)
        formatador.display_line
      rescue => e
        Formatador.display_line("[red]#{output}[/]")
      end
    end
  end
end

desc "Loads the process information from specified Ruby file"
arg_name "file"
command :load do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :load, args)
  end
end

desc "Monitor the specified process or group"
arg_name "process_name"
command :monitor do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :monitor, args)
  end
end

desc "Unmonitor the specified process or group"
arg_name "process_name"
command :unmonitor do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :unmonitor, args)
  end
end

desc "Start the specified process or group"
arg_name "process_name"
command :start do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :start, args)
  end
end

desc "Stop the specified process or group"
arg_name "process_name"
command :stop do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :stop, args)
  end
end

desc "Restart the specified process or group"
arg_name "process_name"
command :restart do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :restart, args)
  end
end

desc "Stop the monitoring daemon without affecting processes"
command :shutdown do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :shutdown, args)
  end
end

def connect_and_perform(global_options, task, args, &block)
  process_name = [*args].first
  output_handler = Proc.new do |socket|
    socket.write("#{task.to_s} #{process_name}")
    socket.flush
    output = socket.gets
    if block
      block.call(output)
    else
      Formatador.display_line(output)
    end
  end

  if global_options[:socket]
    output_handler.call(UNIXSocket.new(global_options[:socket]))
  else
    output_handler.call(TCPSocket.new(global_options["bind-address"], global_options["port"]))
  end
end

def distance_of_time_in_words(seconds)
  minutes = seconds / 60
  return nil if minutes < 0
  case minutes
    when 0               then "less than a minute"
    when 1..59           then pluralize((minutes/1).floor, "minute", "minutes")
    when 60..1439        then pluralize((minutes/60).floor, "hour", "hours")
    when 1440..11519     then pluralize((minutes/1440).floor, "day", "days")
    when 11520..43199    then pluralize((minutes/11520).floor, "week", "weeks")
    when 43200..525599   then pluralize((minutes/43200).floor, "month", "months")  
    else                      pluralize((minutes/525600).floor, "year", "years")
  end
end

SIZE_PREFIX = %w(TiB GiB MiB KiB Bytes).freeze
def number_to_human_size(size)
  size = size.to_f
  i = SIZE_PREFIX.length - 1
  while size > 512 && i > 0
    i -= 1
    size /= 1024
  end
  ((size > 9 || size.modulo(1) < 0.1 ? "%d" : "%.1f") % size) + " " + SIZE_PREFIX[i]
end

def pluralize(count, singular, plural)
  "#{count || 0} " + ((count == 1 || count =~ /^1(\.0+)?$/) ? singular : plural)
end

exit run(ARGV)
