#!/usr/bin/env ruby

require "cognizant/version"
require "gli"
require "formatador"
require "socket"
require "json"

include GLI::App

# Set the process name.
$0 = File.basename(__FILE__)

# Set to flush standard output/error immediately.
$stdout.sync = true
$stderr.sync = true

program_desc "administration utility for cognizantd"
@version = Cognizant::VERSION

sort_help :manually

desc "The socket lock file of the daemon server"
arg_name "FILE"
flag :socket, :type => String, :default_value => "/var/run/cognizant/cognizantd.sock"

desc "The server address of the daemon server"
arg_name "ADDRESS"
flag "bind-address", :type => String

desc "The server port of the daemon server"
arg_name "PORT"
flag :port, :type => Integer

desc "Username to use for authentication with server"
arg_name "USERNAME"
flag :username, :type => String

desc "Password to use for authentication with server"
arg_name "PASSWORD"
flag :password, :type => String

desc "Print the version number and exit"
switch :version, :negatable => false

desc "Turn on tracing, enabling full backtrace"
switch :trace, :negatable => false

desc "Display status of managed process[es]"
arg_name "process_name", :optional
command :status do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :status, args) do |output|
      begin  
        JSON.parse(output)

        status_data = JSON.parse(output)
        status_data.each_with_index do |process, index|
          status_data[index]["State"] = "[green]#{process["State"]}[/] since #{distance_of_time_in_words(Time.now.to_i - process["Since"])}"
        end

        formatador = Formatador.new
        formatador.display_line
        formatador.display_table(status_data, ["Process", "Group", "State"])
        formatador.display_line(Time.now)
        formatador.display_line
      rescue => e
        Formatador.display_line("[red]#{output}[/]")
      end
    end
  end
end

desc "Loads the process information from specified Ruby file"
arg_name "file"
command :load do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :load, args)
  end
end

desc "Monitor the specified process"
arg_name "process_name"
command :monitor do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :monitor, args)
  end
end

desc "Unmonitor the specified process"
arg_name "process_name"
command :unmonitor do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :unmonitor, args)
  end
end

desc "Start the specified process"
arg_name "process_name"
command :start do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :start, args)
  end
end

desc "Stop the specified process"
arg_name "process_name"
command :stop do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :stop, args)
  end
end

desc "Restart the specified process"
arg_name "process_name"
command :restart do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :restart, args)
  end
end

desc "Stop the monitoring daemon"
command :shutdown do |c|
  c.action do |global_options, options, args|
    connect_and_perform(global_options, :shutdown, args)
  end
end

def connect_and_perform(global_options, task, args, &block)
  process_name = [*args].first
  output_handler = Proc.new do |socket|
    socket.write("#{task.to_s} #{process_name}")
    socket.flush
    output = socket.gets
    if block
      block.call(output)
    else
      Formatador.display_line(output)
    end
  end

  if global_options[:socket]
    output_handler.call(UNIXSocket.new(global_options[:socket]))
  else
    output_handler.call(TCPSocket.new(global_options["bind-address"], global_options["port"]))
  end
end

def distance_of_time_in_words(seconds)
  minutes = seconds / 60
  case
    when minutes < 1
      "less than a minute"
    when minutes == 1
      "#{minutes} minute"
    when minutes < 50
      "#{minutes} minutes"
    when minutes < 90
      "about one hour"
    when minutes < 1080
      hours = (minutes / 60).round
      hours == 1 ? "#{hours} hour" : "#{hours} hours"
    when minutes < 1440
      "one day"
    when minutes < 2880
      "about one day"
    else
      "#{(minutes / 1440).round} days"
  end
end

exit run(ARGV)
